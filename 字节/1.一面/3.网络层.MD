### 1、在浏览器输入一个URL的整体过程是怎么样的
  - 【1】当我们在浏览器地址栏按下键盘的时候，浏览器就会启动一个算法去书签栏和历史记录中按照我们输入的字母进行筛选、展示一个我们可能会访问的**URL**
  - 【2】当我们选定了URL按下回车时，浏览器就会开始构建请求行，然后检测这个域名是否合法，如果合法就将此任务给网络请求线程
  - 【3】构建好请求行后就会去检测强缓存是否有效（这个步骤不会发送网络请求），如果无效，就会调用**DNS**协议进行域名解析，如果之前访问过这个**URL**,那么浏览器会把**DNS**解析后的IP地址保存下来，下次访问就直接命中，如果没有就需要去网络运营商或者**DNS**服务器上去找
  - 【4】拿到**DNS**解析的IP地址后就会构建**HTTP**请求，开始**TCP**三次握手建立稳定连接：客户端向服务器发送一个**SYN**（同步序列编码），服务端收到后返回一个新的**SYN + ACK**(在第一个SYN上做计算后生成的回复消息)，客户端收到后回复一个**ACK**，三次握手建立完毕。
  - 【5】建立好三次握手后，**TCP**协议为了传输方便，会将**HTTP**报文切割并编码成一个个数据包，然后转交给网络层
  - 【6】网络层拿到这些数据包后，通过**IP**地址，配合**ARP**协议反查出**MAC**地址，开始传输数据，服务端收到这些数据后，将在**TCP**传输层协议中被分割的报文还原成完整的，这个时候一般会校验是否有权限、是否设置了缓存以及是否过期等。如果设置了协商缓存，那么会返回304状态码通知浏览器使用协商缓存，否则开始响应。响应完毕后，浏览器会判断`Connection`字段是否为`keep-alive`，不是则断开
  - 【7】接下来就是浏览器开始解析请求到的文件，首先调用`GUI`线程并行解析`HTML`和`CSS`文件，对`HTML`文件使用标记化和建树算法,根据文件中使用的`<!DOCTYPE>`标准来生成`DOM`树，对`CSS`文件进行格式化和标准化生成`CSSOM`树，最后合并成合成树。注意`HTML`和`CSS`文件解析是互不影响的，但是会影响最后的合成树生成的速度，所以`CSS`文件中不要放`@import`，她总是在`CSS`文件解析完毕后再去加载对应的资源
  - 【8】另外`GUI`线程和`JS`线程是互斥的，当解析到`HTML`文件中的`script`标签时，就会挂起`GUI`线程，从而阻塞渲染，所以`script`标签中不要写`async`,它总是异步加载，然后立即执行，但是可以写`defer`；拿到合成树后，为了提高渲染效率，因为复杂的图层总是`GUP`单独绘制（GPU加速），不会影响其他的图层，所以开始创建图层树。普通文档流可以算是复杂图层，除此之外`absolute、transform、opacity、canvas`等元素都能形成复杂图层，所以说动画最好放在`absolute`等元素上、用`transform`代替`left/top`
  - 【9】浏览器将这些图层的绘制生成一个个绘制指令，然后交给合成池去进行绘制，生成图块和位图最后显示出当前的页面。
### 2、描述一下浏览器页面渲染的过程


### 3、浏览器白屏是什么导致的
 - 网络阶段，比如第一次访问没有缓存**DNS**对应的**IP**地址，网站设置了301跳转
 - 渲染阶段。浏览器在拿到文件会将它们解析成对应的**DOM**和**CSSOM**，这里有两个方面：第一个方面，由于浏览器的GUI渲染线程和JS线程互斥，所以碰到script标签就会先对JS文件进行解析，从而阻塞渲染，所以要注意书写的位置；第二个方面，如果CSS文件中有@import，那么它会在CSS解析完毕后再进行加载，同样会造成阻塞

### 4、浏览器存储Cookie、localstorage、sessionStorage的区别
 - Cookie
  - 由于HTTP是无状态的应用层协议，导致服务器无法记住客户端用户的操作，而`Cookie`主要是用来记录用户的身份信息，它的大小只有`4kb`，不管服务端是否需要用到它，它总是被来回传递（但是不支持跨域），它和HTTP缓存一样，也可以通过设置`max-age`和`expires`字段决定过期时间
  - 在安全上，由于JS脚本可以读取Cookie,所以我们得通过Set-Cookie中设置httpOnly禁止js读取，预防XSS攻击。除此之外，不应该用Cookie传递敏感信息
  >  所以可以看出Cookie主要是用来维持状态，而不是做本地存储
 - localStorage
  - H5中新提出的Web存储技术，大小是5MB，远大于Cookie体积。由于保存在浏览器端，所以我们可以直接通过API调用
  + 存：`localStorage.setItem('key','value')`
  + 取：`localStorage.getItem('key')`
  - 它的生命周期是永久，除非手动清除。应用场景上，我们可以用他来保存图片这种内容稳定的资源
 - sessionStorage
  - 和`localStorage`一样，不仅都是`H5`提出的`Web`存储技术，而且用法和空间大小也极为相似，最大不同的地方有两点
  + `sessionStorage`的生命周期是当前标签页关闭
  + 无法跨标签页访问，也就是Tab
- 相同点
  - 存储在客户端
  - 不能跨域

### 5、cookie如何进行设置的，JS能改变哪些值
 - name
 - value
 - domain
 - HttpOnly

### 6、描述一下浏览器缓存
- http缓存分为强缓存和协商缓存；
- 强缓存是利用http头中的Expires和Cache-control两个字段来控制的，在强缓存中，当请求再次发出时浏览器会根据其中的expires和cache-control判断目标资源是否命中强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信；
- 协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发送请求、下载完整的响应，还是从本地获取缓存的资源，如果服务端提示缓存资源未改动，资源会被重定向到浏览器缓存，这种情况网络请求对于的状态码是304通过Last-Modified/If-Modified-Since和Etag/If-None-Match实现
### 7、HTTP的状态码有哪些
 - 1XX
  - 100:等待后续处理，比如POST请求发送大实体数据时
 - 2XX
  - 200:请求成功,且返回了请求的数据
  - 204:请求成功,但没有返回任何实体内容
 - 3XX
  - 301:永久重定向
  - 302:临时重定向
  - 304:没有资源更新
 - 4XX
  - 401:需要认证
  - 403:对当前资源没有访问权限
  - 403:没有请求的资源
 - 5XX
  - 502:服务器正常，但发生未知错误。当用户账号或者密码填错时，会出现这个状态码
  - 503:服务器处于停机维护中，就就是没有开启
### 8、HTTP的请求头包含什么
 - 1、`Accept`:text/html 客户端可以接受服务器回发的类型 --> 对应服务端 `Content-Type`
 - 2、`Accept-Encoding`客户端能够理解的内容编码方式(通常是某种压缩算法) --> 对应服务端`Content-Encoding`
 - 3、`Accept-Language`客户端能够理解的自然语言 --> 对应服务端`Content-Language`
 - 4、`Connection`决定当前事务完成后，是否关闭网络链接 可设置为`keep-alive` `close`
 - 5、`Host` 指明了服务端的域名
 - 6、`Referer`当前请求页面的来源页面的地址
 - 7、`Cache-Control`指定缓存机制
 - 8、 `Cookie`

### 9、解决跨域的方法有哪几种
 - jsonp
 - CORS
 - nginx
### 10、描述一下JSONP的原理
 - 因为script标签的src属性不受同源策略影响，所有我们可以现在全局定义一个回调函数，然后在Ajax请求时，将函数名作为参数传递，当服务器返回数据到客户端时执行之前定义好的回调函数
 ```JS
 // 接收三个参数，要发起请求的URL、请求的参数、回调函数
function jsonp({ url, params, cb }) {
    // 这里是拼接参数的方法
    let createUrl = () => {
        // 申明一个字符串
        let dataStr = ''
        // for...in循环遍历参数
        for (let k in params) {
            // 进行拼接
            dataStr += `${k}=${params[k]}&`
        }
        // 最后将回调函数也加上去
        dataStr += `callback=${cb}`
        // 返回最终的结果
        return `${url}?${dataStr}`
    }
    // 返回一个Promise对象
    return new Promise((resolve, reject) => {
        // 在页面上创建script标签
        let script = document.createElement('script')
        // 将script标签中的src属性设置为上面函数返回的参数
        script.src = createUrl()
        // 将script标签插入到body中
        document.body.appendChild(script)
        // 添加回调
        window[cb] = data => {
            // 成功的回调，会将我们要请求的参数作为参数传入
            resolve(data)
            // 执行完毕后移除script标签
            document.body.removeChild(script)
        }
    })
}

 ```
### 11、描述一下CORS的过程
 - 服务端设置`Access-Control-Allow-Origin`就可以开启CORS